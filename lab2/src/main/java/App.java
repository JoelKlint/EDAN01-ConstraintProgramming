import java.util.ArrayList;
import java.util.Arrays;

import org.jacop.constraints.Constraint;
import org.jacop.constraints.IfThen;
import org.jacop.constraints.PrimitiveConstraint;
import org.jacop.constraints.Subcircuit;
import org.jacop.constraints.Sum;
import org.jacop.constraints.XeqC;
import org.jacop.core.IntVar;
import org.jacop.core.Store;
import org.jacop.search.DepthFirstSearch;
import org.jacop.search.IndomainMin;
import org.jacop.search.PrintOutListener;
import org.jacop.search.Search;
import org.jacop.search.SelectChoicePoint;
import org.jacop.search.SimpleMatrixSelect;
import org.jacop.search.SmallestDomain;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

    public static void main(String[] args) {
        System.out.println("Starting lab 2");

        /**
         * Input 1
         */
        // int graph_size = 6;
        // int start = 1;
        // // int n_dests = 1;
        // int[] dest = { 6 };
        // // int n_edges = 7;
        // int[] from = { 1, 1, 2, 2, 3, 4, 4 };
        // int[] to = { 2, 3, 3, 4, 5, 5, 6 };
        // int[] cost = { 4, 2, 5, 10, 3, 4, 11 };

        /**
         * Input 2
         */
        // int graph_size = 6;
        // int start = 1;
        // // int n_dests = 2;
        // int[] dest = { 5, 6 };
        // // int n_edges = 7;
        // int[] from = { 1, 1, 2, 2, 3, 4, 4 };
        // int[] to = { 2, 3, 3, 4, 5, 5, 6 };
        // int[] cost = { 4, 2, 5, 10, 3, 4, 11 };

        /**
         * Input 3
         */
        int graph_size = 6;
        int start = 1;
        // int n_dests = 2;
        int[] dest = { 5, 6 };
        // int n_edges = 9;
        int[] from = { 1, 1, 1, 2, 2, 3, 3, 3, 4 };
        int[] to = { 2, 3, 4, 3, 5, 4, 5, 6, 6 };
        int[] cost = { 6, 1, 5, 5, 3, 5, 6, 4, 2 };

        Store store = new Store();

        // Create variables holder
        IntVar[][] vars = new IntVar[dest.length][graph_size];

        for (int dest_index = 0; dest_index < dest.length; dest_index++) {

            // Build graph
            for (int i = 1; i < vars[dest_index].length + 1; i++) {
                // Create variable
                vars[dest_index][i - 1] = new IntVar(store, Integer.toString(dest_index) + ":" + Integer.toString(i));

                // Add edges
                for (int j = 0; j < from.length; j++) {
                    int from_val = from[j];
                    int to_val = to[j];
                    if (from_val == i) {
                        vars[dest_index][i - 1].addDom(to_val, to_val);
                    }
                    if (to_val == i) {
                        vars[dest_index][i - 1].addDom(from_val, from_val);
                    }
                }

                // You may go to yourself, if you are not the startnode
                if (i != start) {
                    vars[dest_index][i - 1].addDom(i, i);
                }
            }

            // dest may go to start (enables subcircuit)
            int dest_val = dest[dest_index];
            vars[dest_index][dest_val - 1].addDom(start, start);

            // Print initial domains
            // System.out.println(Arrays.toString(vars[dest_index]));

            // Constraint special edge to be included in subcircuit
            int destNode = dest[dest_index];
            Constraint eq_c = new XeqC(vars[dest_index][destNode - 1], start);
            store.impose(eq_c);

            // Impose subcircuit constraint
            Constraint subcircuit = new Subcircuit(vars[dest_index]);
            store.impose(subcircuit);
        }

        /**
         * Define cost function
         */

        //  Build cost matrix
        int[][] edge_costs = new int[graph_size + 1][graph_size + 1];
        for (int i = 0; i < from.length; i++) {
            int from_val = from[i];
            int to_val = to[i];
            edge_costs[from_val][to_val] = cost[i];
            edge_costs[to_val][from_val] = cost[i];
        }

        ArrayList<IntVar> costs = new ArrayList<IntVar>();

        for (int edge_index = 0; edge_index < from.length; edge_index++) {
            IntVar cost_i = new IntVar(store, 0, cost[edge_index]);
            costs.add(cost_i);
            int edge_from = from[edge_index];
            int edge_to = to[edge_index];

            for (int destIndex = 0; destIndex < vars.length; destIndex++) {
                PrimitiveConstraint if_c, then_c;
                Constraint if_then;

                // from --> to
                if_c = new XeqC(vars[destIndex][edge_from - 1], edge_to);
                then_c = new XeqC(cost_i, edge_costs[edge_from][edge_to]);
                if_then = new IfThen(if_c, then_c);
                store.impose(if_then);

                // to --> from
                if_c = new XeqC(vars[destIndex][edge_to - 1], edge_from);
                then_c = new XeqC(cost_i, edge_costs[edge_to][edge_from]);
                if_then = new IfThen(if_c, then_c);
                store.impose(if_then);
            }
        }
        int maxEdgeCost = 11;
        IntVar totalCost = new IntVar(store, "cost", 0, maxEdgeCost * maxEdgeCost);
        Constraint costConstr = new Sum(costs, totalCost);
        store.impose(costConstr);

        /**
         * Initiate search
         */
        Search<IntVar> search = new DepthFirstSearch<IntVar>();

        SelectChoicePoint<IntVar> select = new SimpleMatrixSelect<IntVar>(vars, new SmallestDomain<IntVar>(),
                new IndomainMin<IntVar>());

        search.setSolutionListener(new PrintOutListener<IntVar>());

        boolean result = search.labeling(store, select, totalCost);

        if (result) {
            System.out.println("\n*** Yes!");
            for (IntVar[] sol : vars) {
                System.out.println("Solution : " + java.util.Arrays.asList(sol));

            }
            System.out.println("Cost: " + totalCost.value());

        } else {
            System.out.println("NOOOO! ");
        }

        // // Print all vars
        // for (IntVar var : vars[0]) {
        //     System.out.println(var);
        // }
        // for (IntVar var : vars[1]) {
        //     System.out.println(var);
        // }
    }
}
